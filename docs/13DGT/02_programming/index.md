---
title: "Unit 2: Programming Project"
programme: "Year 13 Digital Technologies"
aligned_standard: "AS91906 – Programming Project"
version: "1.0.0"
status: "Student-facing"
last_updated: "2026-01-17"
---

# Unit 2: Programming Project

This unit prepares you for **AS91906 – Programming Project**, a 10-week internal assessment focused on algorithm design, implementation, testing discipline, and code quality.

---

## Unit Overview

You will learn to:
- design efficient algorithms and select appropriate data structures
- implement clear, maintainable code with strong documentation
- write comprehensive tests and systematically debug failures
- manage a multi-week project from specification to completion
- demonstrate your understanding through live code walkthroughs

By the end of this unit, you will have completed a substantial programming project with evidence of planning, iterative development, testing discipline, and deep understanding of your code.

---

## Topics in This Unit

- [1. Algorithm Design & Complexity](01_algorithm-design-complexity.md) – Designing efficient solutions
- [2. Code Quality & Maintainability](02_code-quality-maintainability.md) – Writing readable, well-documented code
- [3. Testing & Debugging](03_testing-debugging.md) – Writing tests and systematically finding/fixing bugs
- [4. Data Structures](04_data-structures.md) – Choosing the right structure for the problem
- [5. Development Process](05_development-process.md) – Managing a multi-week project
- [6. Version Control & Git](06_version-control-git.md) – Tracking code changes and development history

---

## How This Unit Relates to Assessment

**AS91906 – Programming Project** requires you to submit:

1. **Problem specification and design document** (pseudocode, algorithm descriptions, data structure choices)
2. **Well-commented source code** with clear structure and meaningful variable names
3. **Test plan and testing evidence** (at least 10 test cases covering normal, boundary, and error scenarios)
4. **Development journal** tracking progress, debugging decisions, and iterations
5. **Code walkthrough recording or live explanation** demonstrating understanding of core logic
6. **Reflection on development process** identifying challenges and lessons learned

This unit's topics directly support these requirements:
- Topics 1–2 prepare you for algorithm design and code quality
- Topic 3 prepares you for comprehensive testing and debugging
- Topics 4–6 support project management and documentation

---

## Key Concepts to Master

By the end of this unit, you must understand and be able to explain:

- **Algorithm design:** Breaking problems into logical steps and choosing efficient approaches
- **Code clarity:** Why readable code is more important than "clever" code
- **Testing discipline:** Why testing is not optional; it's how you verify correctness
- **Data structures:** How choice of structure (array, linked list, hash table, tree) impacts performance
- **Debugging strategy:** How to find and fix bugs systematically, not by guessing
- **Development process:** How to manage large projects through planning, incremental development, and verification
- **Documentation:** Why explaining your code in comments and docstrings helps you and others understand it

---

## Important Assessment Reminders

### Continuous Formative Checkpoints

Your teacher will collect evidence **weekly**:
- Pseudocode and design sketches
- Working code (even if incomplete)
- Test execution logs
- Git commit history
- Development journal entries

**This is not optional.** Weekly checkpoints help you stay on track and give your teacher visibility into your thinking.

### Live Code Walkthrough

Before final submission, you will **explain your code** to your teacher or record a walkthrough where you:
- explain the algorithm and why you chose it
- walk through key functions and explain their logic
- demonstrate how your code handles edge cases
- show your test results and explain what each test verifies
- discuss challenges you faced and how you solved them

Your teacher will ask questions like:
- *"Walk me through this function. What does it do?"*
- *"Why did you choose this data structure?"*
- *"What would happen if the input was empty?"*
- *"How did you debug this issue?"*

If you can't explain your code, it's not valid evidence—no matter how well it runs.

### AI Use Restrictions (AS91906-Specific)

- ✗ AI-generated code without understanding is not acceptable
- ✗ Submitting code you can't explain or modify is not acceptable
- ✓ AI tools may help you understand concepts (e.g., "explain recursion")
- ✓ AI tools may help you debug specific errors if you verify the fix
- ✓ AI tools may suggest test cases (which you adapt and justify)

**Development journal must document any AI use honestly.**

---

## Timeline (Indicative)

- **Week 1–2:** Problem specification, algorithm design, pseudocode
- **Week 3–4:** Initial implementation, testing setup
- **Week 5–6:** Core functionality, bug fixes, feature implementation
- **Week 7–8:** Comprehensive testing, edge case handling, optimization
- **Week 9–10:** Final refinement, documentation, code walkthrough preparation

---

## Languages Supported

- **JavaScript** (Node.js) — recommended for beginners; large community
- **Python** — excellent for learning; great libraries
- **Other languages** — permitted with prior teacher approval (C++, Java, etc.)

---

## Common Pitfalls to Avoid

1. **No design phase:** Jumping straight to code wastes time. Spend Week 1 designing.
2. **Ignoring edge cases:** Testing only the happy path misses bugs. Test boundaries and errors.
3. **Inadequate documentation:** Your teacher can't verify understanding without comments and docstrings.
4. **No version control:** Missing git history makes it hard to trace development and detect AI-generated code.
5. **Last-minute testing:** Testing in Week 9 leaves no time to fix bugs. Test continuously.
6. **Unclear variable names:** `x`, `temp`, `data` don't explain purpose. Use `userScore`, `previousNode`, `employeeList`.
7. **Monolithic functions:** 200-line functions are unmaintainable. Break into smaller, testable units.
8. **No reflection:** Don't just submit code; reflect on challenges and lessons learned.

---

## External Resources

### Algorithm Design
- **[Big O Notation Explained (YouTube)](https://www.youtube.com/watch?v=V6mKVRU1evU)** – Understanding algorithm efficiency
- **[LeetCode](https://leetcode.com/)** – Practice problems with detailed explanations

### Code Quality
- **[Clean Code (Robert Martin)](https://www.oreilly.com/library/view/clean-code-a/9780136083238/)** – Classic book on code quality (library copy)
- **[Google Python Style Guide](https://google.github.io/styleguide/pyguide.html)** – Best practices for naming and formatting

### Testing
- **[Testing Best Practices](https://www.nngroup.com/articles/testing/)** – Overview of testing types
- **[Jest Testing Framework](https://jestjs.io/)** – For JavaScript unit testing

### Git & Version Control
- **[Git Tutorial (Atlassian)](https://www.atlassian.com/git/tutorials)** – Clear guides to git basics
- **[GitHub Learning Lab](https://lab.github.com/)** – Interactive git training

---

## Key Vocabulary

- **Algorithm:** Step-by-step procedure to solve a problem
- **Big O notation:** Way to express algorithm efficiency (O(n), O(n²), etc.)
- **Boundary test:** Testing with edge values (empty, zero, very large, very small)
- **Bug:** Error in code causing unexpected behavior
- **Data structure:** Way to organize and store data (array, list, hash table, tree, graph)
- **Debugging:** Process of finding and fixing bugs
- **Function:** Reusable block of code that does one thing
- **Pseudocode:** Plain English description of an algorithm before coding
- **Recursion:** Function calling itself to solve smaller versions of the same problem
- **Refactoring:** Improving code without changing functionality
- **Test case:** Specific input and expected output used to verify correctness
- **Unit test:** Test of a single function or component in isolation
- **Variable:** Named storage location for a value

---

## Navigating Unit 2

Start with [01_algorithm-design-complexity.md](01_algorithm-design-complexity.md) and work through each topic in order.

---

*End of Unit 2 Overview*
